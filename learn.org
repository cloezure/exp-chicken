* GETTING STARTED
csi - интерпретатор chicken
сsc - компилятор chicken

** REPL
.scm - файлы chicken
(load <path-to-file>) - процедура загрузки файла в REPL

*** Toplevel commands
- ,?
    выводит все доступные комманды
- ,c
    элементы трассировки вызова последней ошибки
- ,ch
    очищает сохранённые результаты выражений от прошлых вычисленных выражений
- ,d EXP
    подробный результат выражения EXP
- ,du EXP
    дамп содержимого результата выражения EXP
- ,dur EXP N
    дамп N байт результата EXP
- ,e FILENAME
    запускае внешний редактор для редактирования файла FILENAME
- ,exn
    описывает последнее исключение и добавляет его в журнал результатов
       (доступ к журналу результатов можно получить через #)
- ,f N
    выберите элемент трассировки вызовов с заданным номеромб где число 0
       указывает на последний элемент в трассировке
- ,g NAME
    возвращает значение локальной переменной с заданным именем NAME
    (,g - вернёт первую переменную которая соответствует указанному префиксу)
- ,h
    показывает все ранее вычисленные результаты
- ,l FILENAME ...
    загружает файлы с заданными именами FILENAMEs
- ,ln FILENAME ...
    загружает файлы и печатает результат(ы) каждого выражения top-level
- ,m MODULENAME
    переключает "текущий модуль" на MODULENAME, поэтому выражения будут
    оцениваться в контексте данного модуля. Чтобы вернуться к верхнему уровню,
    используется #f в качестве MODULENAME. В скомпилированных модулях для
    интерактивно введенного кода будут видны только экспортированные привязки.
    В интерпретируемых модулях видны все привязки.
- ,p EXP
    симпатичный вывод вычисляемого выражения EXP
- ,q
    выход из интерпретатора
- ,r
    показывает системную информацию
- ,s TEXT ...
    передаёт TEXT в командную оболочку, и после печатает результат
- ,t EXP
    вычисляет форму и печатает прошедшее время
- ,x EXP
    симпотично печатает макрорасширения выражения EXP (выражение не вычисляется)
Так же можно определять свои toplevel комманды используя toplevel-command процедуру

** SCRIPTS
(import (chicken NAME)) - загрузка библиотеки NAME в модуль

csi -ss - вызывает процедуру с именем main, в качестве аргументов которой используются
аргументы командрной строки, упакованные в список.

** COMPILER
*комманда chicken аналогична csc*

csc - удобный инструмент, автоматизирующий компиляцию программ scheme в C,
компиляция кода C в объектный код и компоновка результатов в исполняемый файл.

чтобы скомпилировать файл .scm в shared object {.so,dll}

#+BEGIN_SRC bash
  csc -shared fact.scm # создаёт .so
  csi -quiet # -quiet не печатает баннер
#+END_SRC

чтобы скомпилировать программу [[file:palindrome.scm][palindrome]] в исполняемую мы пишем

#+BEGIN_SRC bash
  csc -o palindrome palindrome.scm # создаёт исполняемый файл
  ./palindrome level # level is a palindrome
  ./palindrome liver # liver isn't a palindrome
#+END_SRC

chicken поддерживает раздельную компиляцию, использую некоторые расширения scheme.
Разделим нашу программу на библиотеку [[file:pal-proc.scm][pal-proc.scm]] и клиента [[file:pal-usr.scm][pal-usr.scm]]

(declare (unit pal-proc)) - объявляем(declare) что это модуль(unit)
(declare (uses pal-proc)) - объявляем(declare) что мы используем(uses) модуль

Теперь мы можем скомпилировать и собрать всё вместе.

#+BEGIN_SRC bash
  csc -c pal-proc.scm
  csc -c pal-usr.scm

  csc -o pal-separate pal-proc.o pal-usr.o
  ./pal-separate level # level is a palindrome
#+END_SRC

** INSTALLING AN EGG
Установка библиотек происходит через комманду chicken-install. Комманда chicken-install
извлечёт яйцо из главного репозитория chicken и установит его в локальной системе

для примера можно установить uri-common
#+BEGIN_SRC bash
  chicken-install uri-common
#+END_SRC

chicken-install подключается к зеркалу хранилища яиц и извлекает библиотеку.
Если у библиотеки есть какие-либо удаленные зависимости, тогда chicken-install рекурсивно
установит их. Затем chicken-install собирает код библиотеки и устанавливает полученный
результат в локальный репозиторий chicken.

** ACCESSING C LIBRARIES
Поскольку chicken компилируется в C и поскольку интерфейс взаимодействия с другими
функциями встроенн в компилятор, взаимодействие с библиотекой C довольно простое.

Создадим простую библиотеку на C, чтобы увидеть как это работает.
Создадим [[file:fib.c][fib.c]] файл который вернёт n-ое число фибоначчи.

Теперь мы можем вызвать эту функцию из chicken [[file:fib-usr.scm][fib-usr.scm]]

Синтаксис "#>...<#" позволяет включать литерал C (внешние объявления) в chicken код.
Мы получаем доступ к fib, определяя для него внешнюю лямбду, в данном случае говоря,
что функция принимает один целочисленный аргумент (int) и это возвращает целочисленный
результат (int). Теперь мы можем вызвать xfib, как если бы это была обычная функция.

#+BEGIN_SRC bash
  gcc -c fib.c
  csc -o fib-usr fib.o fib-usr.scm
  ./fib-usr # 0 1 1 2 3 5 8 13 21 34 55
#+END_SRC

При взаимодействии со значительными библиотеками C, используется bind egg

* USING THE INTERPRETER
** WRITING SCHEME SCRIPTS
Поскольку оболочки UNIX используют обозначение #! для запуска сценариев, все, что
следует за символами #!, игнорируется, за исключением специльных символов:
- #!optional
- #!key
- #!rest
- #!eof

Самый простой путь это использование опции -script:

[[file:foo][foo]]
#+BEGIN_SRC sh
  cat foo
  chmod +x foo
  ./foo "(+ 3 4)" # 7
#+END_SRC

Параметр command-line-arguments устанавливается ввиде списка параметров, которые
были переданы сценарию scheme. Скрипты могут быть скомпилированы
в автономные исполняемые файлы.

Поскольку иногда бывает полезно скрипт в интерпретаторе, фактически не выполняя его
(для тестирования определенных частей), параметр -ss можно использовать в качестве
альтернативы -script. -ss PATHNAME эквивалентно -script PATHNAME, но вызывает
*(main (command-line-arguments))* после загрузки всех верхних форм скрипта.
Результат main возвращается в качестве статуса выхода в shell. Любой нечисловой результат
завершается с нулевым статусом:

[[file:learn.org][hi.scm]]
#+BEGIN_SRC bash
  cat hi.scm
  csi -ss hi.scm you # Hi, you
  csi -q
#+END_SRC
#+BEGIN_SRC scheme
  ,l hi.scm
  (main (list "ye all"))
  ;; Hi, ye all
  0
#+END_SRC

Когда csi запускается с опцией -script, определяется идентификатор функции chicken-script,
поэтому можно условно выполнять код в зависимости от того, выполняется ли файл как скрипт
или обычно загружается в интерпретатор для отладки.

#+BEGIN_SRC sh
  #!/bin/sh
  #|
     exec csi -s "$0" "$@"
  |#

  (import (chicken process-context))

  (define (main args) ...)

  (cond-expand
   (chicken-script
    (main (command-line-arguments)))
   (else))
#+END_SRC

** GETTING ERROR INFORMATION
Интерпретаторуемый код имеет расширеную отладочную информацию, которую можно использовать
для обнаружения ошибок и получения информации о лексической среде, которая была активна
в момент ошибки. Когда в вычисляемом выражении возникает ошибка, выводится
"трассировка вызовов" - список вызовов до места ошибки. Это просто список недавно выпол-
ненных вызовов процедур, где последним в списке является вызов любой процедуры,
выполнявшейся до возникновения ошибки. Можно использовать команду ,c чтобы показать
трассировку вызова последней ошибки. В зависимости от того, выполнялся ли скомпилированный
или интерпретированный код и какой сколько отладочной информации доступно, трассировка
вызова показывает записи буфера трассировки следующего вида:

*<frame-number>:<environment?> <mode> <procedure-name> <form>*

<frame-number> - указывает номер записи трассировки вызовов, считая с нуля и начиная с
самой последней записи. если после номера кадра следует [], то этот кадр содержит
лексическое окружение, действовавшее в момент вызова процедуры.

<mode> - является необязательным и представляет собой <syntax> или <eval>, указывая,
представляет ли эта запись буфера трассировки синтаксическое расширение или оценку, и
не задается для скомпилированного кода.

<form> - также доступен только для интерпретируемого кода и показывает выражение вызова
процедуры, возможно, после имени процедуры, содержащей выражение вызова.

Если запись в буфере трассировки содержит информацию о лексическом окружении, то
показывается полное окружение места вызова.

Используется ,f - для выбора фрейма по номеру, если вы хотите проверить лексическое
окружение более раннего фрейма. ,g - позволяет получить значение локальной или
лексической переменной из текущего выбранного фрейма. (переменные переименованы, чтобы
упростить поиск переменных, выполняемый интерпретатором внутри.

** RUNNING AN EXTERNAL EDITOR
Комманда ,e запускает редактор полученный через:
- Параметр editor-command в модуле (chicken csi) должен возвращать строку с
  названием внешнего редактора и по умолчанию имеет значение #f, что означает, что
  в данный момент не выбран ни один из редактор
- Содержимое переменных окружения EDITOR или VISUAL
- Если установлена переменная окружения EMACS, то выбранный редактор - emacsclient
- В отчаянной попытке найти редактор используется vi.

** HISTORY ACCESS
Toplevel принимает спецальные объекты #INDEX, который возвращает результат записи
с номером INDEX в списке истории. Если выражение для этой записи привело к нескольким
значениям, возвращается первый результат (или неопределенное значение
при отсутствии значений). Если INDEX не указан (и если за # следует пробел или
закрывающий символ скобки, то возвращается результат последнего выражения.
#INDEX является выражением, а не литералом, и поэтому неявно квотирован.

** AUTO-COMPLETION AND EDITING
Можно получить более функциональную среду благодаря breadline egg.

** CSI COMMAND LINE FORMAT
/csi {FILENAME|OPTION}/

где FILENAME указывает на файл с исходным кодом scheme. Если расширение файла - .scm
его можно опустить. Опция времени выполнения, описанные в разделе COMPILER доступны
из интерпретатора. Если в переменной окружения CSI_OPTIONS задан список опций, то
эти опции дополнительно передаются при каждом прямом или косвенном вызове csi.
Интерпретатор распознает следующие опции:

...





