* GETTING STARTED
CHICKEN - это компилятор который транслирует Scheme в исходные файлы Си, которые,
в свою очередь, могут быть переданы компилятору Си для создания автономного
исполняемого файла.

Имеется также интерпретатор, который можно использовать в качестве среды написания
сценариев или для тестирования программ перед компиляцией.

csi - интерпретатор chicken.
сsc - компилятор chicken.

** REPL
.scm - файлы chicken
(load <path-to-file>) - процедура загрузки файла в REPL

*** Toplevel commands
,?
  Выводит все доступные комманды.
,c
  Элементы трассировки вызова последней ошибки.
,ch
  Очищает сохранённые результаты выражений от прошлых вычисленных выражений.
,d EXP
  Подробный результат выражения EXP.
,du EXP
  Дамп содержимого результата выражения EXP.
,dur EXP N
  Дамп N байт результата EXP.
,e FILENAME
  Запускае внешний редактор для редактирования файла FILENAME.
,exn
  Описывает последнее исключение и добавляет его в журнал результатов
  (доступ к журналу результатов можно получить через #).
,f N
  Выберите элемент трассировки вызовов с заданным номеромб где число 0
  указывает на последний элемент в трассировке
,g NAME
  Возвращает значение локальной переменной с заданным именем NAME
  (,g - вернёт первую переменную которая соответствует указанному префиксу)
,h
  Показывает все ранее вычисленные результаты.
,l FILENAME ...
  Загружает файлы с заданными именами FILENAMEs.
,n FILENAME ...
  Загружает файлы и печатает результат(ы) каждого выражения top-level.
,m MODULENAME
  Переключает "текущий модуль" на MODULENAME, поэтому выражения будут
  оцениваться в контексте данного модуля. Чтобы вернуться к верхнему уровню,
  используется #f в качестве MODULENAME. В скомпилированных модулях для
  интерактивно введенного кода будут видны только экспортированные привязки.
  В интерпретируемых модулях видны все привязки.
,p EXP
  Симпатичный вывод вычисляемого выражения EXP.
,q
  Выход из интерпретатора.
,r
  Показывает системную информацию.
,s TEXT ...
  Передаёт TEXT в командную оболочку, и после печатает результат.
,t EXP
  Вычисляет форму и печатает прошедшее время.
,x EXP
  Симпотично печатает макрорасширения выражения EXP (выражение не вычисляется).
  Так же можно определять свои toplevel комманды используя toplevel-command процедуру.

** SCRIPTS
(import (chicken NAME)) - загрузка библиотеки NAME в модуль

csi -ss - вызывает процедуру с именем main, в качестве аргументов которой используются
аргументы командрной строки, упакованные в список.

** COMPILER
*комманда chicken аналогична csc*

csc - удобный инструмент, автоматизирующий компиляцию программ scheme в C,
компиляция кода C в объектный код и компоновка результатов в исполняемый файл.

чтобы скомпилировать файл .scm в shared object {.so,dll}

#+BEGIN_SRC bash
  csc -shared fact.scm # создаёт .so
  csi -quiet # -quiet не печатает баннер
#+END_SRC

чтобы скомпилировать программу [[file:palindrome.scm][palindrome]] в исполняемую мы пишем

#+BEGIN_SRC bash
  csc -o palindrome palindrome.scm # создаёт исполняемый файл
  ./palindrome level # level is a palindrome
  ./palindrome liver # liver isn't a palindrome
#+END_SRC

chicken поддерживает раздельную компиляцию, использую некоторые расширения scheme.
Разделим нашу программу на библиотеку [[file:pal-proc.scm][pal-proc.scm]] и клиента [[file:pal-usr.scm][pal-usr.scm]]

(declare (unit pal-proc)) - объявляем(declare) что это модуль(unit)
(declare (uses pal-proc)) - объявляем(declare) что мы используем(uses) модуль

Теперь мы можем скомпилировать и собрать всё вместе.

#+BEGIN_SRC bash
  csc -c pal-proc.scm
  csc -c pal-usr.scm

  csc -o pal-separate pal-proc.o pal-usr.o
  ./pal-separate level # level is a palindrome
#+END_SRC

** INSTALLING AN EGG
Установка библиотек происходит через комманду chicken-install. Комманда chicken-install
извлечёт яйцо из главного репозитория chicken и установит его в локальной системе

для примера можно установить uri-common
#+BEGIN_SRC bash
  chicken-install uri-common
#+END_SRC

chicken-install подключается к зеркалу хранилища яиц и извлекает библиотеку.
Если у библиотеки есть какие-либо удаленные зависимости, тогда chicken-install рекурсивно
установит их. Затем chicken-install собирает код библиотеки и устанавливает полученный
результат в локальный репозиторий chicken.

** ACCESSING C LIBRARIES
Поскольку chicken компилируется в C и поскольку интерфейс взаимодействия с другими
функциями встроенн в компилятор, взаимодействие с библиотекой C довольно простое.

Создадим простую библиотеку на C, чтобы увидеть как это работает.
Создадим [[file:fib.c][fib.c]] файл который вернёт n-ое число фибоначчи.

Теперь мы можем вызвать эту функцию из chicken [[file:fib-usr.scm][fib-usr.scm]]

Синтаксис "#>...<#" позволяет включать литерал C (внешние объявления) в chicken код.
Мы получаем доступ к fib, определяя для него внешнюю лямбду, в данном случае говоря,
что функция принимает один целочисленный аргумент (int) и это возвращает целочисленный
результат (int). Теперь мы можем вызвать xfib, как если бы это была обычная функция.

#+BEGIN_SRC bash
  gcc -c fib.c
  csc -o fib-usr fib.o fib-usr.scm
  ./fib-usr # 0 1 1 2 3 5 8 13 21 34 55
#+END_SRC

При взаимодействии со значительными библиотеками C, используется bind egg

* USING THE INTERPRETER
** WRITING SCHEME SCRIPTS
Поскольку оболочки UNIX используют обозначение #! для запуска сценариев, все, что
следует за символами #!, игнорируется, за исключением специальных символов:
- #!optional
- #!key
- #!rest
- #!eof

Самый простой путь это использование опции -script:

[[file:foo][foo]]
#+BEGIN_SRC sh
  cat foo
  chmod +x foo
  ./foo "(+ 3 4)" # 7
#+END_SRC

Параметр command-line-arguments устанавливается ввиде списка параметров, которые
были переданы сценарию scheme. Скрипты могут быть скомпилированы
в автономные исполняемые файлы.

Поскольку иногда бывает полезно скрипт в интерпретаторе, фактически не выполняя его
(для тестирования определенных частей), параметр -ss можно использовать в качестве
альтернативы -script. -ss PATHNAME эквивалентно -script PATHNAME, но вызывает
*(main (command-line-arguments))* после загрузки всех верхних форм скрипта.
Результат main возвращается в качестве статуса выхода в shell. Любой нечисловой результат
завершается с нулевым статусом:

[[file:learn.org][hi.scm]]
#+BEGIN_SRC bash
  cat hi.scm
  csi -ss hi.scm you # Hi, you
  csi -q
#+END_SRC
#+BEGIN_SRC scheme
  ,l hi.scm
  (main (list "ye all"))
  ;; Hi, ye all
  0
#+END_SRC

Когда csi запускается с опцией -script, определяется идентификатор функции chicken-script,
поэтому можно условно выполнять код в зависимости от того, выполняется ли файл как скрипт
или обычно загружается в интерпретатор для отладки.

#+BEGIN_SRC sh
  #!/bin/sh
  #|
     exec csi -s "$0" "$@"
  |#

  (import (chicken process-context))

  (define (main args) ...)

  (cond-expand
   (chicken-script
    (main (command-line-arguments)))
   (else))
#+END_SRC

** GETTING ERROR INFORMATION
Интерпретируемый код имеет расширеную отладочную информацию, которую можно использовать
для обнаружения ошибок и получения информации о лексической среде, которая была активна
в момент ошибки. Когда в вычисляемом выражении возникает ошибка, выводится
"трассировка вызовов" - список вызовов до места ошибки. Это просто список недавно выпол-
ненных вызовов процедур, где последним в списке является вызов любой процедуры,
выполнявшейся до возникновения ошибки. Можно использовать команду ,c чтобы показать
трассировку вызова последней ошибки. В зависимости от того, выполнялся ли скомпилированный
или интерпретированный код и какой сколько отладочной информации доступно, трассировка
вызова показывает записи буфера трассировки следующего вида:

*<frame-number>:<environment?> <mode> <procedure-name> <form>*

<frame-number> - указывает номер записи трассировки вызовов, считая с нуля и начиная с
самой последней записи. если после номера кадра следует [], то этот кадр содержит
лексическое окружение, действовавшее в момент вызова процедуры.

<mode> - является необязательным и представляет собой <syntax> или <eval>, указывая,
представляет ли эта запись буфера трассировки синтаксическое расширение или оценку, и
не задается для скомпилированного кода.

<form> - также доступен только для интерпретируемого кода и показывает выражение вызова
процедуры, возможно, после имени процедуры, содержащей выражение вызова.

Если запись в буфере трассировки содержит информацию о лексическом окружении, то
показывается полное окружение места вызова.

Используется ,f - для выбора фрейма по номеру, если вы хотите проверить лексическое
окружение более раннего фрейма. ,g - позволяет получить значение локальной или
лексической переменной из текущего выбранного фрейма. (переменные переименованы, чтобы
упростить поиск переменных, выполняемый интерпретатором внутри.

** RUNNING AN EXTERNAL EDITOR
Комманда ,e запускает редактор полученный через:
- Параметр editor-command в модуле (chicken csi) должен возвращать строку с
  названием внешнего редактора и по умолчанию имеет значение #f, что означает, что
  в данный момент не выбран ни один из редактор
- Содержимое переменных окружения EDITOR или VISUAL
- Если установлена переменная окружения EMACS, то выбранный редактор - emacsclient
- В отчаянной попытке найти редактор используется vi.

** HISTORY ACCESS
Toplevel принимает спецальные объекты #INDEX, который возвращает результат записи
с номером INDEX в списке истории. Если выражение для этой записи привело к нескольким
значениям, возвращается первый результат (или неопределенное значение
при отсутствии значений). Если INDEX не указан (и если за # следует пробел или
закрывающий символ скобки, то возвращается результат последнего выражения.
#INDEX является выражением, а не литералом, и поэтому неявно квотирован.

** AUTO-COMPLETION AND EDITING
Можно получить более функциональную среду благодаря breadline egg.

** CSI COMMAND LINE FORMAT
/csi {FILENAME|OPTION}/

где FILENAME указывает на файл с исходным кодом scheme. Если расширение файла - .scm
его можно опустить. Опция времени выполнения, описанные в разделе COMPILER доступны
из интерпретатора. Если в переменной окружения CSI_OPTIONS задан список опций, то
эти опции дополнительно передаются при каждом прямом или косвенном вызове csi.
Интерпретатор распознает следующие опции:

--
  Игнорируйте все, что написано в командной строке после этого маркера. 
  Опции времени выполнения (-:...) по-прежнему распознаются.

-i -case-insensitive
  Позволяет считывателю читать символы без учета регистра.
  По умолчанию чтение осуществляется с учетом регистра.

-b -batch
  Выход из интерпретатора после обработки всех опций командной строки.

-e -eval EXPRESSIONS
  Вычисляет EXPRESSIONS. Эта опция подразумевает -batch, -no-init и -quiet, поэтому
  сообщение о запуске не выводится, а интерпретатор щавершает работу после обработки всех
  опций -eval и/или загрузки файлов, заданных в командной строке.

-p -print EXPRESSIONS
  Вычисляет EXPRESSIONS и выводит результат каждого выражения с помощью print. подразумевает
  -batch, -no-init и -quiet.

-P -pretty-print EXPRESSIONS
  Вычисляет EXPRESSIONS и выводит результат каждого выражения с помощью pretty-print.
  подразумевает -batch, -no-init и -quiet.

-D -feature SYMBOL
  регистрирует SYMBOL как действительный идентификатор функции для cond-expand и feature?

-h -help
  Выводит краткую информацию о доступных опциях командной строки в стандартный вывод и ввод.

-I -include-path PATHNAME
  Указывает альтернативный путь поиска для файлов, включенных с помощью специальной формы
  include. Этот параметр может быть задан несколько раз. Если установлена переменная
  окружения CHICKEN_INCLUDE_PATH, она должна содержать список альтернативных путей включения,
  разделенных : (UNIX) или ; (WINDOWS).

-K -keyword-style STYLE
  Включает альтернативный синтаксис ключевых слов, где STYLE может быть префиксом
  (как в common lisp), либо суффиксом (как в DSSSL). Любое другое значение игнорируется.

-n -no-init
  Не загружает файл инициализации. Если эта опция не задана и файл $HOME/.csirc существует,
  то он будет загружен до начала цикла read-eval-print.

-no-parentheses-synonyms
  Отключает синонимы разделителя списка, [...] и {...} для (...)

-no-symbol-escape
  Отключает поддержку экранированных символов, форму |...|.

-w -no-warnings
  Отключает любые предупреждения, которые могут быть выданы считываетелем или
  оцененным кодом.

-q -quiet
  Отключает печать сообщения о запуске. Отключается генерация информации о 
  трассировке вызовов для интерпретируемого кода.

-r5rs-syntax
  Отключает расширения CHICKEN для синтаксиса R5RS. Не отключает
  нестандартный синтаксис чтения.

-s -script PATHNAME
  Эквивалентно -batch, -quiet, -no-init PATHNAME. Аргументы, следующие за PATHNAME
  доступны с помощью аргументов командной строки и не обрабатываются как опции
  интерпретатора. Дополнительные параметры в переменной окружения CSI_OPTIONS игнорируются.

-sx PATHNAME
  То же, что и -s PATHNAME, но печатает каждое выражение в (current-error-port) перед оценкой.

-ss PATHNAME
  То же, что и -s PATHNAME, но вызывает процедуру main со значением (command-line-arguments)
  в качестве единственного аргумента. Если процедура main возвращает целочисленный
  результат, то интерпретатор завершается, возвращая целое число в качестве кода
  состояния обратно вызывающему процессу. Любой другой результат приводит к завершению
  работы интерпретатора с нулевым статусом выхода.

-setup-mode
  При поиске расширений, сначала выполняется поиск в текущем каталоге. По умолчанию,
  расширения сначала находятся в репозитории расширений, где chicken-install хранит
  скомпилированные расширения и связанные с ними метаданные.

-R -require-extension NAME
  Эквивалентно вычисления (require-extension NAME).

-v -version
  Выводит баннер с информацией о версии в стандартный ввод/вывод.

* USING THE COMPILER
Компилятор csc предоставляет удобный интерфейс к базовому транслятору scheme-to-C (chicken)
и заботится о компиляции и компоновке сгенерированных Си-файлов в исполняемый код.

chicken FILENAME OPTION ...

** BASIC COMMAND-LINE OPTIONS
-analyze-only
  Останавливает компиляцию после первого прохода аналализа.

-block
  Включает блочную-компиляцию. Когда эта опция указана, компилятор предполагает,
  что глобальные переменные не изменяются за пределами данного блока компиляции.
  В частности, toplevel привязки не видны вычислителю и неиспользуемые 
  toplevel привязки удаляются.

-case-insensitive
  Позволяет считывателю читать символы без учета регистра.
  По умолчанию чтение осуществляется с учетом регистра.

-check-syntax
  Прерывает компиляцию после расширения макросов и проверки синтаксиса.

-clustering
  Если возможно, комбинирует группы локальных процедур в dispatch-loops.

-consult-inline-file FILENAME
  Загружает файл с определениями для кросс-модульного инлайнинга,
  созданный предыдущим вызовом компилятора через -emit-inline-file.
  Подразумевает -inline.

-debug MODES
  Включает один или несколько режимов отладки компилятора.
  MODES - это строка символов, выбирающих отладочную информацию
  о компиляторе, которая будет выводится на стандартный вывод.
  Используйте -debug h для просмотра списка доступных опций отладки.

-debug-level LEVEL
  Выбирает количество отладочной информации. LEVEL должен быть целым числом,
  где 0 эквивалентно -no-trace -no-lambda-info, 1 эквивалентно 
  -no-trace, 2 - поведение по умолчанию и 3 эквивалентно -debug-mode.

-disable-interrupts
  Эквивалентно объявлению (disable-interrupts). Для скомпилированных
  программ не генерируются проверки на прерывания, что отключает переключение
  контекста потока в этой (и только этой) единице компиляции.

-disable-stack-overflow-checks
  Отключает обнаружения переполнений стека. Это эквивалентно 
  запуску скомпилированного исполняемого файла с опцией времени выполнения -:o

-dynamic
  Этот параметр следует использовать при компиляции файлов, предназначенных для
  динамической загрузки в работающую программу scheme.

-epilogue FILENAME
  Включает файл с именем FILENAME в конец скомпилированного исходного файла.
  Поиск в include-path не происходит. Эта опция может быть задана несколько раз.

-emit-all-import-libraries
  Эмитировать библиотеки импорта для всех модулей, определенных в текущем блоке
  вычисления.

...


